/*MailingList.cpp
 *
 *MailingList objects represent the individual lists handled by a server
 *
 *
 *Copyright 2013-2014 Andrew Wood awood@comms.org.uk
 *All rights reserved
 */
 
#include "MailingList.h"
#include "IncomingMail.h"
#include "MailMistressApplication.h"
#include "AppWideBMessageDefs.h"
#include <storage/Directory.h>
#include <storage/File.h>
#include <storage/Path.h>
#include <storage/NodeMonitor.h>
#include <storage/Entry.h>
#include <app/Application.h>
#include <image.h>
#include <OS.h>
#include <stdlib.h>
#include <sstream>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cctype>
#include <mail/MailMessage.h>

extern BApplication* be_app;

class IncomingMail;

MailingList::MailingList(std::string icemail, std::string ogenvemail,std::string listname,std::string subjectpre,std::string dirpath,std::string authprogpath,std::string logfilepath, 
						bool forcetolist, std::string listowner, std::string listhelp, std::string listarchive, std::string listsubscribe, std::string listunsubscribe)
{
	fApp=(MailMistressApplication*) be_app;
	fListICAddress=icemail; 
	fListOGEnvelopeAddressFromAddress=ogenvemail;
	fListName=listname;
	fListInDirectoryPath=dirpath;
	fAuthProgPath=authprogpath;
	fLogFilePath=logfilepath;
	fMaxContentBytes=100000000;
	fLogSuccesses=true;
	fPlainTextOnly='N';
	fListSubjectPrefix=subjectpre;	//already has [] surrounding it, this was done by MailMistressApplication
	fForceReplyToList=forcetolist;
	fListOwner=listowner; //will be null str if not set in conf file
	fListHelp=listhelp; //will be null str if not set in conf file
	fListArchive=listarchive; //will be null str if not set in conf file
	fListSubscribe=listsubscribe; //will be null str if not set in conf file
	fListUnSubscribe=listunsubscribe; //will be null str if not set in conf file
	
	//set generic bounce msg in case there is a problem reading the custom msg file
	fUnauthorisedBounceMsgContents=std::string("You are not authorised to post to the mailing list: ");
	fUnauthorisedBounceMsgContents=fUnauthorisedBounceMsgContents+fListName+" ("+fListICAddress+")\n\n";
	fUnauthorisedBounceMsgContents=fUnauthorisedBounceMsgContents+"This message was automatically generated by the "+fApp->GetAppName();
	fUnauthorisedBounceMsgContents=fUnauthorisedBounceMsgContents+" for Haiku mailing list server at "+fListICAddress+"\nPlease contact the list owner for more details\n";
	
	
}

bool MailingList::InitLogFileSemaphores()
{
	//return false if error
	if (fLogFileSem = create_sem(1,"fLogFileSem") < B_NO_ERROR)
	{
			return false;
	}
	return true;
}
	
void MailingList::SetBounceMsg(std::string path)
{
	//attempt to read the custom bounce message file
	BFile bouncemsgbfile;
	status_t bouncemsgfilestatus=bouncemsgbfile.SetTo(path.c_str(),B_READ_ONLY);
	if (bouncemsgfilestatus==B_NO_ERROR)
	{
		off_t bytes; //size of file
		if (bouncemsgbfile.GetSize(&bytes) == B_NO_ERROR)
		{
			
			char* buff = new char[bytes];
			off_t bytesread=bouncemsgbfile.Read(buff,bytes);
			if ( (bytesread > 0) && (bytesread < 50001)  )
			{
				//file read ok
				std::string oldbouncemsg=fUnauthorisedBounceMsgContents; //save generic bounce msg so it can be appended later
				fUnauthorisedBounceMsgContents=""; //clear existing contents
				for (int x=0; x < bytesread; x++)
				{
					fUnauthorisedBounceMsgContents=fUnauthorisedBounceMsgContents+buff[x];
				}	
				fUnauthorisedBounceMsgContents=fUnauthorisedBounceMsgContents+"\n\n"+oldbouncemsg; //append generic msg
			}
			delete buff;
			
		}
		bouncemsgbfile.Unset(); //close file
	}
}
void MailingList::SetArchivePath(std::string path)
{
	fArchivePath=path;
}

void MailingList::SetMaxMsgBytes(unsigned long int bytes)
{
	//will be adjusted down by the Go() method if app limit is lower
	fMaxContentBytes=bytes;
}

void MailingList::Go()
{
	if (fApp->GetMaxMsgBytes() < fMaxContentBytes)
	{
		fMaxContentBytes=fApp->GetMaxMsgBytes();	
	}
	if  (fApp->GetPlainTextOnly()=='Y')
	{
		if  ( (fPlainTextOnly=='N') )
		{
			LogError("INFO: List is set to allow HTML text messages and attachments but server isn't. List setting is being overridden by server setting");
		}
		else if  (fPlainTextOnly=='H') 
		{
			LogError("INFO: List is set to allow HTML text messages but server isn't. List setting is being overridden by server setting");
		}
		fPlainTextOnly='Y';
	}
	else if (fApp->GetPlainTextOnly()=='H')
	{
		if  ( (fPlainTextOnly=='N') )
		{
			LogError("INFO: List is set to allow HTML text messages  but server isn't. List setting is being overridden by server setting");
			fPlainTextOnly='H';
		}
		
		
	}
	//setup Node Monitor to send messages to app if a new file appears
	BDirectory indir(fListInDirectoryPath.c_str());
	node_ref indir_node_ref;
	status_t err;
	
	if (indir.InitCheck() == B_OK)
	{
		indir.GetNodeRef(&indir_node_ref);
		err=watch_node(&indir_node_ref,B_WATCH_DIRECTORY,be_app);
		if (err!=B_OK)
		{
			//could not set watch on BDirectory
			exit;		
		}
	}
	else
	{
		//could not init BDirectory
		exit;	
	}
	//now process any files which were already in the dir when we launched
	BMessage msg(B_PULSE);
	fApp->PostMessage(&msg,NULL);
}
void MailingList::SetPlainTextOnly(char pto)
{
	fPlainTextOnly=pto;	
}

bool MailingList::ProcessEmailFile(std::string emailfilepathstr)
{
	/*
		Check if sender of email is authorised to post to this list, if not return true and caller will delete file
		else copy it to an outgoing email with relevent header changes, queue og mail for delivery
		and return true so caller will delete file.
		Any errors return false
	*/
	
	
	BFile* bfile = new BFile(emailfilepathstr.c_str(),B_READ_WRITE);
	
	if (bfile->InitCheck() != B_NO_ERROR)
	{
		LogError("ERROR: Could not process an incoming email. BFile::InitCheck was false");
		return false;
	}

	IncomingMail* ICMail= new IncomingMail(bfile,this);
	if (ICMail->InitCheck()==false)
	{
		LogError("ERROR: Could not process an incoming email. File read failed. IncomingMail::InitCheck was false");
		return false;
	}
	
	if (fLogSuccesses)
	{
		LogError("INFO: Processing an email file from "+ICMail->GetSendersAddr());
	}
	
	
	int32 authstatus=1;
	
	/*
		Return vals from external auth prog are 
		0=Authorised
		1=Error
		2=Not Authorsed - bounce msg
		3=Not Authorised - silently discard
		
		This func should return false if val is 1, thus ensuring the incoming file is not deleted and will be re-processed later
		for all other values it should return true, indicating that the incoming file can be deleted
	*/
	int32 arg_c = 4; //no of args passed in arg_v
	extern char **environ; //env variables
	char **arg_v;
	arg_v = (char **) malloc(sizeof(char*) * (arg_c+1)); //array must hold arg_c elements + a terminating null
	
	std::stringstream epochsecs;
	epochsecs << real_time_clock(); //secs now since unix epoch
	int filenamecounterInt=0; //will be incremented until we get a unique filename string
	bool nonuniquefilename=true;
	BEntry tempFileBEntry;
	std::string tempFilePath;
	do
	{
		filenamecounterInt++;
		std::stringstream filenamecounter;
		filenamecounter << filenamecounterInt;
		MailMistressApplication* app=(MailMistressApplication*) be_app;
		tempFilePath=app->GetTempDirPath()+fListICAddress+"--"+ICMail->GetSendersAddr()+"--"+epochsecs.str()+filenamecounter.str();
		//test if tempFilePath already exists
		tempFileBEntry.SetTo(tempFilePath.c_str());
		BFile tempFileBFile;
		status_t tempFileResult=tempFileBFile.SetTo(&tempFileBEntry,B_READ_WRITE|B_FAIL_IF_EXISTS|B_CREATE_FILE); //fails if already exists
		if (tempFileResult==B_FILE_EXISTS)
		{
			nonuniquefilename=true;	
		}
		else if (tempFileResult==B_NO_ERROR)
		{
			nonuniquefilename=false;
			tempFileBFile.Unset(); //close file
		}
		else
		{
			//error
			bfile->Unset();
			//delete ICMail obj
			delete ICMail;
			delete bfile;

			return false;
		}
		
	}while(nonuniquefilename);
	
	
	arg_v[0]=strdup(fAuthProgPath.c_str()); //path to exe
	arg_v[1]=strdup((ICMail->GetSendersAddr()).c_str()); //senders email addr
	arg_v[2]=strdup(tempFilePath.c_str()); //path to temp file
	arg_v[3]=strdup(fListICAddress.c_str()); //list IC address
	arg_v[4]=NULL;
	
	thread_id authprog_team;
	authprog_team=load_image(arg_c,(const char**)arg_v,(const char**)environ);
	free(arg_v);
	wait_for_thread(authprog_team,&authstatus);
	//if authstatus==0 then temp file will now contain all recipient email addresses one per line
	
	if (authstatus==0)
	{
		//send to recipients in temp file
		if (DistributeEmail(ICMail,tempFilePath))
		{
				//delete temp file
				tempFileBEntry.Remove();
				
				//delete ICMail obj
				delete ICMail;
				
				//close orig email file
				bfile->Unset();
				delete bfile;
				return true;
		}
		else
		{
				//delete temp file
				tempFileBEntry.Remove();
				
				//delete ICMail obj
				delete ICMail;
				
				//close orig email file
				bfile->Unset();
				delete bfile;
			
				return false;
		}
	}
	else if (authstatus==2)
	{
			LogError("INFO: Auth status 2 -- Bouncing to "+ICMail->GetSendersAddr());
			BMailMessage* ogmail;
			ogmail= new BMailMessage();
			ogmail->AddHeaderField(B_MAIL_TO,(ICMail->GetSendersAddr()).c_str());
			ogmail->AddHeaderField(B_MAIL_FROM,fListOGEnvelopeAddressFromAddress.c_str());
			std::string bouncesubject=std::string("Undelivered mail: Your message to ");
			bouncesubject=bouncesubject+fListName+" was rejected";
			ogmail->AddHeaderField(B_MAIL_SUBJECT,bouncesubject.c_str());
			ogmail->AddHeaderField("X-Mailer: ",(fApp->GetAppName()).c_str());
    	  	ogmail->AddContent(fUnauthorisedBounceMsgContents.c_str(),strlen(fUnauthorisedBounceMsgContents.c_str()));
			ogmail->Send();
			delete ogmail;
	}
	else if (authstatus==3)
	{
			LogError("INFO: Auth status 3 -- Silently discarding email from "+ICMail->GetSendersAddr());	
			
	}
	
	//delete temp file
	tempFileBEntry.Remove();
	
	if ( (authstatus==2) || (authstatus==3)  )
	{
		//ok so return true to delete incoming file
		delete ICMail;
		bfile->Unset();
		delete bfile;
		
		return true;	
	}
	else
	{
		//error occured so return false and incoming file will be kept for reprocessing later
		LogError("ERROR: Auth status 1 (or other error value). Either the autentication program failed to run or it encountered an error itself");
		delete ICMail;
		bfile->Unset();
		delete bfile;
	
		return false;	
	}
	
}

bool MailingList::DistributeEmail(IncomingMail* ICMail, std::string ogaddrfilepath)
{
	
	//send ICMail to every address in ogaddrfilepath
	std::vector<std::string> recipients;
	BFile recipientlistbfile;
	status_t filestatus=recipientlistbfile.SetTo(ogaddrfilepath.c_str(),B_READ_ONLY);
	if (filestatus!=B_NO_ERROR)
	{
		LogError("ERROR: Could not read temp file from authentication program - the file could not be opened. Does it exist?");
		return false;	
	}
		off_t bytes; //size of file
		if (recipientlistbfile.GetSize(&bytes) == B_NO_ERROR)
		{
		
			char* buff = new char[bytes];
			off_t bytesread=recipientlistbfile.Read(buff,bytes);
			if (bytesread > 0)
			{
				//file read ok
	
				std::string addr="";
	
				for (int x=0; x < bytesread; x++)
				{
					if (buff[x]!='\n')
					{
						addr=addr+buff[x];
					}
					else
					{
						recipients.push_back(addr);
						addr="";	
					}
				}	
				delete buff;
			}
			else
			{
				LogError("ERROR: Could not read temp file from authentication program - the file was empty");
				delete buff;
				return false;	
			}
		}
		else
		{
			LogError("ERROR: Could not read temp file from authentication program -- could not determine file size");
			return false;	
		}
		
		ICMail->AddSubjectPrefix(fListSubjectPrefix); //fListSubjectPrefix will be null str if not defined in conf file
		ICMail->CleanHeaders(); //clean & setup headers ready for sending message out to recipients
		ICMail->AdjustReplyTo(fForceReplyToList); //set reply to to either sender or list IC address
		
		//if List-Xyz header values were set in conf file we need to set them in msg
		if (fListOwner!="")
		{
			ICMail->SetListOwnerHeader(fListOwner);
		}
		if (fListHelp!="")
		{
			ICMail->SetListHelpHeader(fListHelp);
		}
		if (fListArchive!="")
		{
			ICMail->SetListArchiveHeader(fListArchive);
		}
		if (fListSubscribe!="")
		{
			ICMail->SetListSubscribeHeader(fListSubscribe);
		}
		if (fListUnSubscribe!="")
		{
			ICMail->SetListUnSubscribeHeader(fListUnSubscribe);
		}
	//call GetFromField to get email address in case we need to bounce msg 

	std::string ICsendersAddrField=ICMail->GetSendersAddr(); //returns null string if unable to find
	//at present ICsendersAddrField now has address in form user@domain NOT <user@domain> is this in line with RFC spec?
	


	if (ICMail->CheckIfPlainTextCriteriaPassed(fPlainTextOnly)==false)
	{
		//bounce
		if (fPlainTextOnly=='Y')
		{
				//bounce to sender
				LogError("INFO: Incoming email not text/plain and non plain text messages are not allowed. Bounced to "+ICsendersAddrField);
				BMailMessage* ogmail;
				ogmail= new BMailMessage();
				ogmail->AddHeaderField(B_MAIL_TO,ICsendersAddrField.c_str());
				ogmail->AddHeaderField(B_MAIL_FROM,fListOGEnvelopeAddressFromAddress.c_str());
				std::string bouncesubject=std::string("Undelivered mail: Your message to ");
				bouncesubject=bouncesubject+fListName+" was rejected";
				ogmail->AddHeaderField(B_MAIL_SUBJECT,bouncesubject.c_str());
				std::string xmailer=(fApp->GetAppName())+" mailing list server for Haiku";
				ogmail->AddHeaderField("X-Mailer: ",xmailer.c_str());
				ogmail->AddHeaderField("precedence: ","list");
				std::string bouncecontent="Your message to "+fListName+" was rejected because this list only accepts plain text messages. Make sure your email program is not creating HTML or Rich Text emails and that there are no attached files.";
				bouncecontent=bouncecontent+"\n\nThis is an automated reply sent from the "+fApp->GetAppName()+" for Haiku server at "+fListICAddress;
    			ogmail->AddContent(bouncecontent.c_str(),strlen(bouncecontent.c_str()));
				ogmail->Send();
				delete ogmail;
		}
		else
		{
				//fPlainTextOnly must be 'H'
				//bounce to sender
				LogError("INFO: Incoming email not HTML or plain text and non text messages are not allowed. Bounced to "+ICsendersAddrField);
				BMailMessage* ogmail;
				ogmail= new BMailMessage();
				ogmail->AddHeaderField(B_MAIL_TO,ICsendersAddrField.c_str());
				ogmail->AddHeaderField(B_MAIL_FROM,fListOGEnvelopeAddressFromAddress.c_str());
				std::string bouncesubject=std::string("Undelivered mail: Your message to ");
				bouncesubject=bouncesubject+fListName+" was rejected";
				ogmail->AddHeaderField(B_MAIL_SUBJECT,bouncesubject.c_str());
				std::string xmailer=(fApp->GetAppName())+" mailing list server for Haiku";
				ogmail->AddHeaderField("X-Mailer: ",xmailer.c_str());
				ogmail->AddHeaderField("precedence: ","list");
				std::string bouncecontent="Your message to "+fListName+" was rejected because this list only accepts HTML or plain text messages. Make sure that there are no attached files.";
				bouncecontent=bouncecontent+"\n\nThis is an automated reply sent from the "+fApp->GetAppName()+" for Haiku server at "+fListICAddress;
    			ogmail->AddContent(bouncecontent.c_str(),strlen(bouncecontent.c_str()));
				ogmail->Send();
				delete ogmail;
		}
		return true;
	}

	
	if (ICMail->GetICFileSize() > fMaxContentBytes)
	{
		//msg too big bounce to sender
		LogError("INFO: Incoming email too big. Bounced to "+ICsendersAddrField);
		BMailMessage* ogmail;
		ogmail= new BMailMessage();
		ogmail->AddHeaderField(B_MAIL_TO,ICsendersAddrField.c_str());
		ogmail->AddHeaderField(B_MAIL_FROM,fListOGEnvelopeAddressFromAddress.c_str());
		std::string bouncesubject=std::string("Undelivered mail: Your message to ");
		bouncesubject=bouncesubject+fListName+" was rejected";
		ogmail->AddHeaderField(B_MAIL_SUBJECT,bouncesubject.c_str());
		std::string xmailer=(fApp->GetAppName())+" mailing list server for Haiku";
		ogmail->AddHeaderField("X-Mailer: ",xmailer.c_str());
		ogmail->AddHeaderField("precedence: ","list");
		stringstream converter;
		converter << fMaxContentBytes << " bytes, your message was " << ICMail->GetICFileSize() << " bytes";
		std::string toobigcontent="Your message to "+fListName+" is too big and was rejected. Maximum allowable size for this list is "+converter.str();
		toobigcontent=toobigcontent+"\n\nThis is an automated reply sent from the "+fApp->GetAppName()+" for Haiku server at "+fListICAddress;
    	ogmail->AddContent(toobigcontent.c_str(),strlen(toobigcontent.c_str()));
		ogmail->Send();
		delete ogmail;
		return true;
	}



	//setup a temp file to store the modified og msg
	std::stringstream epochsecs;
	epochsecs << real_time_clock(); //secs now since unix epoch
	int filenamecounterInt=0; //will be incremented until we get a unique filename string
	bool nonuniquefilename=true;
	BEntry tempFileBEntry;
	std::string tempFilePath;
	BFile* tempFileBFile = new BFile();
	do
	{
		filenamecounterInt++;
		std::stringstream filenamecounter;
		filenamecounter << filenamecounterInt;
		tempFilePath=fApp->GetTempDirPath()+fListICAddress+"--"+epochsecs.str()+filenamecounter.str();
		//test if tempFilePath already exists
		tempFileBEntry.SetTo(tempFilePath.c_str());
		status_t tempFileResult=tempFileBFile->SetTo(&tempFileBEntry,B_READ_WRITE|B_FAIL_IF_EXISTS|B_CREATE_FILE); //fails if already exists
		if (tempFileResult==B_FILE_EXISTS)
		{
			nonuniquefilename=true;	
		}
		else if (tempFileResult==B_NO_ERROR)
		{
			nonuniquefilename=false;
			
		}
		else
		{
			//error
			LogError("ERROR: Could not create temp file to store outgoing email");
			return false;
		}
		
	}while(nonuniquefilename);

	//Write modified msg into temp file

	ICMail->WriteToFile(tempFileBFile);



	//store senders addr so we can log it later
	std::string sender="";
	//Send out modified msg in temp file to all recipients
	for (int x=0; x< recipients.size(); x++)
	{
		std::string recipient=recipients[x];
		
		BEmailMessage* ogmail;
		ogmail= new BEmailMessage(tempFileBFile);
    	ogmail->SetTo(recipient.c_str());
    	sender=std::string(ogmail->From());
    	//1st version of send indicates whether to change the From: field to the specified account (requires modified mailkit)
		ogmail->SendViaAccountWithFromPreset(fListOGEnvelopeAddressFromAddress.c_str());
		//ogmail->SendViaAccount(fListOGEnvelopeAddressFromAddress.c_str());
		ogmail->Send(true);
		delete ogmail;
		
	}
	tempFileBFile->Unset(); //close file
	delete tempFileBFile; //delete obj
	//archive msg if needed
	bool archived=false;
	if (fArchivePath!="")
	{
			
			BDirectory dir;
			if ( dir.SetTo(fArchivePath.c_str()) !=B_OK )
			{
				LogError("ERROR: Could not archive message. Check archive folder exists and is writable");
			}
			else
			{
				if ( tempFileBEntry.MoveTo(&dir) !=B_NO_ERROR)
				{
					LogError("ERROR: Could not archive message. Check archive folder exists and is writable");
				}
				else
				{
					archived=true;	
				}
			}
			
	}
	if (archived==false)
	{
		//if archived  then the file was moved so we dont need to delete the original
		tempFileBEntry.Remove();//remove file from filesystem	
	}
	
	stringstream numRecipients;
	numRecipients << recipients.size();
	
	if ( (fLogSuccesses) && (recipients.size()>0)  )
	{
		//if we recipients.size() was 0 sender var is null str as its set in the distribution loop
		LogError("INFO: Successfully distributed an email to "+numRecipients.str()+" recipients from "+sender);
	}
	return true;
}

void MailingList::LogError(std::string msg)
{
			if (fLogFilePath=="")
			{
				//log file not yet set (as during startup conf file pasrsing) 	
				//use printf instead and dont warn about log file
				printf(fApp->GetDateTime().c_str());
				printf(" ");
				printf(msg.c_str());
				printf("\n");
				return;
			}	
			
			//check we can open file ok
			//lock sem to prevent other threads accessing file
			acquire_sem(fLogFileSem);
			BFile logbfile;
			status_t logfilestatus=logbfile.SetTo(fLogFilePath.c_str(),B_READ_WRITE|B_CREATE_FILE|B_OPEN_AT_END);
			
			if (logfilestatus ==B_NO_ERROR)
			{
				std::string time=fApp->GetDateTime();
				time=time+" ";
				logbfile.Write(time.c_str(),strlen(time.c_str()));
				logbfile.Write(msg.c_str(),strlen(msg.c_str()));
				char nl='\n';
				logbfile.Write(&nl,1);
				logbfile.Unset(); //close file
				
			}
			else
			{
					//log file could not be opened use printf instead and do warn about log file
					printf(fApp->GetDateTime().c_str());
					printf(" ");
					printf(msg.c_str());
					printf(" ADDITIONALLY THIS MESSAGE SHOULD HAVE GONE TO THE LOG FILE BUT IT COULD NOT BE OPENED.");
					printf(" Check %s has write permission to the specified file %s",(fApp->GetAppName()).c_str(),fLogFilePath.c_str());
					printf("\n");
					
			}
			//unlock file sem
			release_sem(fLogFileSem);
			
			
}

void MailingList::CheckInFolder()
{
	//always called in the context of a MailWorker
	
	//manually check through in dir to see if there are any emails	
	BDirectory indir(fListInDirectoryPath.c_str());
	if (indir.InitCheck()!=B_OK)
	{
			LogError("ERROR: Could not do manual scan of in folder ("+fListInDirectoryPath+") as there was an error reading the folder (BDirectory InitCheck() failed)");
			fApp->LogError("ERROR: List ("+fListName+") could not do manual scan of in folder ("+fListInDirectoryPath+") as there was an error reading the folder (BDirectory InitCheck() failed)");
	}
	entry_ref eref;
	BEntry filebentry;
	while(indir.GetNextEntry(&filebentry) == B_NO_ERROR)
	{
		BMessage msg(ORG_SIMPLE_MAILMISTRESS_PROCESSFILE);
		BPath filebpath;
		filebentry.GetPath(&filebpath);
		std::string pathstr(filebpath.Path());
		msg.AddString("FilePathStr",pathstr.c_str());
		((MailMistressApplication*) be_app)->PostMessage(&msg);
		
	}
}
std::string MailingList::GetName()
{
	return fListName;	
}
std::string MailingList::GetICAddress()
{
	return fListICAddress;
}	
std::string MailingList::GetSubjectPrefix()
{
	return fListSubjectPrefix;	
}

void MailingList::DeleteLogFileSem()
{
	delete_sem(fLogFileSem);	
}

